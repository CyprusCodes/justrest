"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[616],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var r=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,s=function(e,n){if(null==e)return{};var t,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var o=r.createContext({}),u=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=u(e.components);return r.createElement(o.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,s=e.mdxType,a=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(t),m=s,g=p["".concat(o,".").concat(m)]||p[m]||d[m]||a;return t?r.createElement(g,l(l({ref:n},c),{},{components:t})):r.createElement(g,l({ref:n},c))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var a=t.length,l=new Array(a);l[0]=p;var i={};for(var o in n)hasOwnProperty.call(n,o)&&(i[o]=n[o]);i.originalType=e,i.mdxType="string"==typeof e?e:s,l[1]=i;for(var u=2;u<a;u++)l[u]=t[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5316:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return c}});var r=t(7462),s=t(3366),a=(t(7294),t(3905)),l=["components"],i={id:"query-interface",title:"Query Interface",sidebar_label:"Query Interface"},o=void 0,u={unversionedId:"query-interface",id:"query-interface",isDocsHomePage:!1,title:"Query Interface",description:"submitQuery",source:"@site/docs/query-interface.md",sourceDirName:".",slug:"/query-interface",permalink:"/docs/query-interface",editUrl:"https://github.com/CyprusCodes/xest/tree/main/documentation/docs/docs/query-interface.md",tags:[],version:"current",frontMatter:{id:"query-interface",title:"Query Interface",sidebar_label:"Query Interface"},sidebar:"docs",previous:{title:"Managing Migrations",permalink:"/docs/managing-migrations"},next:{title:"Authentication",permalink:"/docs/authentication"}},c=[{value:"submitQuery",id:"submitquery",children:[],level:2},{value:"sql",id:"sql",children:[],level:2},{value:"sqlId",id:"sqlid",children:[],level:2},{value:"sqlValueOrNull",id:"sqlvalueornull",children:[],level:2},{value:"Transactions",id:"transactions",children:[],level:2},{value:"camelKeys",id:"camelkeys",children:[],level:2},{value:"getFirst",id:"getfirst",children:[],level:2},{value:"getProperty",id:"getproperty",children:[],level:2},{value:"getInstertIds",id:"getinstertids",children:[],level:2},{value:"getInsertId",id:"getinsertid",children:[],level:2},{value:"toCSV",id:"tocsv",children:[],level:2},{value:"ToUnionAll",id:"tounionall",children:[],level:2},{value:"nest",id:"nest",children:[],level:2}],d={toc:c};function p(e){var n=e.components,t=(0,s.Z)(e,l);return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"submitquery"},"submitQuery"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"submitQuery")," gives you the property of using the sql language inside backticks."),(0,a.kt)("h2",{id:"sql"},"sql"),(0,a.kt)("p",null,"This helper is used when you want to stitch together bits of SQL, below is an example where ",(0,a.kt)("inlineCode",{parentName:"p"},"invoiceId")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"clientId")," variables are used to construct a ",(0,a.kt)("strong",{parentName:"p"},"WHERE")," clause dynamically. User can provide either of these two parameters when calling ",(0,a.kt)("inlineCode",{parentName:"p"},"selectMiscCharges")," query."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, sql } = require("~root/database");\n\nconst selectMiscCharges = ({\n  invoiceId,\n  clientId\n}) => submitQuery`\n SELECT\n    misc_charges.invoice_id,\n    misc_charges.client_id\n  FROM\n    misc_charges\n  WHERE\n    1 = 1\n    ${invoiceId ? sql`AND misc_charges.invoice_id = ${invoiceId}` : sql``}\n    ${clientId ? sql`AND misc_charges.client_id = ${clientId}` : sql``}\n`;\n\nmodule.exports = selectMiscCharges;\n')),(0,a.kt)("h2",{id:"sqlid"},"sqlId"),(0,a.kt)("p",null,"This helper is used when you want to set ",(0,a.kt)("em",{parentName:"p"},"table names"),", or ",(0,a.kt)("em",{parentName:"p"},"column names")," in your query dynamically. It gives you protection against SQL injection attacks. It uses ",(0,a.kt)("inlineCode",{parentName:"p"},"mysql.escapeId")," utility behind the scenes. You can refer to docs ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/mysqljs/mysql#escaping-query-identifiers"},"here"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, sqlId } = require("~root/database");\nconst TagGroupAssociatedWith = require("~root/constants/TagGroupAssociatedWith");\n\nconst COLUMN = {\n  [TagGroupAssociatedWith.order]: "order_id",\n  [TagGroupAssociatedWith.sku]: "sku_id",\n  [TagGroupAssociatedWith.product]: "product_id",\n  [TagGroupAssociatedWith.delivery]: "delivery_id"\n};\n\nconst removeAnnotations = ({\n  annotationGroupId,\n  entityId,\n  associatedWith\n}) => submitQuery`\n    DELETE FROM annotations\n    WHERE annotation_group_id = ${annotationGroupId}\n    AND ${sqlId(COLUMN[associatedWith])} = ${entityId}\n`;\n\nmodule.exports = removeAnnotations;\n')),(0,a.kt)("h2",{id:"sqlvalueornull"},"sqlValueOrNull"),(0,a.kt)("p",null,"This helper is used when writing UPDATE or INSERT queries where target column is a NULLABLE field. It converts any ",(0,a.kt)("strong",{parentName:"p"},"undefined")," variables to NULL values."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, sqlValueOrNull } = require("~root/database");\n\nconst updateOrderImportLogs = ({\n  orderImportLogId,\n  importCompletedAt,\n  apiErrors,\n  orderImportErrors,\n  importedOrders,\n  failedOrders,\n  skippedOrders\n}) => submitQuery`\n  UPDATE \n    order_import_logs\n  SET\n    import_completed_at = ${sqlValueOrNull(importCompletedAt)},\n    api_errors = ${sqlValueOrNull(apiErrors)},\n    import_errors = ${sqlValueOrNull(orderImportErrors)},\n    imported_orders = ${sqlValueOrNull(importedOrders)},\n    failed_orders = ${sqlValueOrNull(failedOrders)},\n    skipped_orders = ${sqlValueOrNull(skippedOrders)}\n  WHERE\n    order_import_log_id = ${orderImportLogId}\n`;\n\nmodule.exports = updateOrderImportLogs;\n')),(0,a.kt)("h2",{id:"transactions"},"Transactions"),(0,a.kt)("p",null,"Xest allows you to work with SQL transactions by utilising 3 helper functions in your actions. If any of the queries within the transaction block fails, all queries within the transaction will be reverted."),(0,a.kt)("p",null,"You'll have to wrap all the queries you want to be part of the transaction between ",(0,a.kt)("inlineCode",{parentName:"p"},"startTransaction")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"commitTransaction")," calls in a try/catch block, and make sure you call ",(0,a.kt)("inlineCode",{parentName:"p"},"rollbackTransaction")," in the catch section."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const deleteProductSkus = require("../../queries/deleteProductSkus");\nconst deleteProduct = require("../../queries/deleteProduct");\n\nconst {\n  startTransaction,\n  commitTransaction,\n  rollbackTransaction\n} = require("~root/database");\n\nconst removeBundle = async ({ productId }) => {\n  try {\n    await startTransaction();\n\n    await deleteProductSkus({\n      productId\n    });\n\n    await deleteProduct({ productId });\n\n    await commitTransaction();\n  } catch (err) {\n    await rollbackTransaction();\n    throw new Error("Failed to delete product");\n  }\n};\n\nmodule.exports = removeBundle;\n')),(0,a.kt)("h2",{id:"camelkeys"},"camelKeys"),(0,a.kt)("p",null,"By convention SQL developers tend to use ",(0,a.kt)("strong",{parentName:"p"},"snake_case")," whilst naming column and table names, whereas JavaScript developers tend to prefer ",(0,a.kt)("strong",{parentName:"p"},"camelCase")," in their code. camelKeys helper converts snake_case column names to camelCase when using SELECT queries."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, camelKeys } = require("~root/database");\n\nconst selectServiceLevels = () => submitQuery`\n  SELECT \n     service_level, \n     priority_score\n  FROM service_levels\n`;\n\nmodule.exports = camelKeys(selectServiceLevels);\n')),(0,a.kt)("p",null,"Returned data from the above query will look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"[ \n  { serviceLevel: 1, priorityScore: 10 },\n  { serviceLevel: 2, priorityScore: 30 }\n]\n")),(0,a.kt)("h2",{id:"getfirst"},"getFirst"),(0,a.kt)("p",null,"This helper is used when you want to ",(0,a.kt)("strong",{parentName:"p"},"query just a single record")," from a table. Instead of getting an array of values, your query will return a single object -- the first row from the resultset."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, getFirst } = require("~root/database");\n\nconst selectUserName = ({ userId }) => submitQuery`\n  SELECT \n     user_id,\n     name \n  FROM users \n  WHERE user_id = ${userId}\n`;\n\nmodule.exports = getFirst(selectUser);\n')),(0,a.kt)("p",null,"Above query will return"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'{ user_id: 1, name: "ersel" }\n')),(0,a.kt)("p",null,"You can also pick a single column from the resulting row, by supplying a second argument to the getFirst helper."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'module.exports = getFirst(selectUser, "name");\n')),(0,a.kt)("p",null,"The above query will return ",(0,a.kt)("inlineCode",{parentName:"p"},"ersel")," (a string value)."),(0,a.kt)("h2",{id:"getproperty"},"getProperty"),(0,a.kt)("p",null,"This helper is useful when you want to fetch an array of values from the target table and column."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, getProperty } = require("~root/database");\n\nconst selectUserNames = () => submitQuery`\n  SELECT \n     name \n  FROM users\n`;\n\nmodule.exports = getProperty(selectUserNames, "name");\n')),(0,a.kt)("p",null,"Above query will return an array of strings."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'["ersel", "buse", "kemal"]\n')),(0,a.kt)("h2",{id:"getinstertids"},"getInstertIds"),(0,a.kt)("p",null,"This helper is used to get the ID of the last inserted record."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, getInsertId } = require("~root/database");\n\nconst insertCycle = ({ systemId }) => submitQuery`\n  INSERT INTO cycles(\n    system_id\n  ) VALUES(\n    ${systemId}\n  )\n`;\n\nmodule.exports = getInsertId(insertCycle);\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Usage:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const insertedCycleId = await insertCycle({ systemId: 1 });\n// insertedCycleId will be the primary key of the last inserted record in cycles table\n")),(0,a.kt)("h2",{id:"getinsertid"},"getInsertId"),(0,a.kt)("p",null,"You can also get the insert ids of multiple insert values."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, sql, getInsertIds, toCSV } = require("~root/database");\n\nconst insertReadings = ({ systemId, readings }) => submitQuery`\n  INSERT INTO readings(\n    system_id,\n    system_type_metric_id,\n    time_from,\n    time_to,\n    reading\n  ) VALUES \n    ${readings\n      .map(reading => {\n        return sql`(\n          ${systemId},\n          ${reading.systemTypeMetricId},\n          ${reading.timeFrom},\n          ${reading.timeTo},\n          ${reading.reading}\n        )`;\n      })\n      .reduce(toCSV)}\n`;\n\nmodule.exports = getInsertIds(insertReadings);\n')),(0,a.kt)("h2",{id:"tocsv"},"toCSV"),(0,a.kt)("p",null,"This helper is used to concatenate sql statements as comma seperated values. Useful when you're doing a queries with ",(0,a.kt)("inlineCode",{parentName:"p"},"IN()")," operator."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, toCSV } = require("~root/database");\n\nconst deleteReadings = ({ readingIds }) => submitQuery`\n  DELETE FROM\n    readings\n  WHERE\n    reading_id IN(${readingIds.reduce(toCSV)})\n`;\n\nmodule.exports = deleteReadings;\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Usage:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"await deleteReadings({ readingIds: [1,2,3] }); // reading records with ids 1,2,3, will be deleted\n")),(0,a.kt)("h2",{id:"tounionall"},"ToUnionAll"),(0,a.kt)("p",null,"This helper is used to construct multiple select statements with UNION ALL operatior between."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const {\n  submitQuery,\n  sql,\n  sqlReduceWithUnion,\n  sqlValueOrNull\n} = require("~root/database");\n\nconst insertMatchedProducts = ({ products, clientSalesChannelId }) => {\n  return submitQuery`\n    INSERT INTO client_sales_channel_product_mapping(\n      product_id,\n      client_sales_channel_id,\n      sales_channel_product_ref,\n      client_sales_channel_listing_id,\n      fulfilment_opt_in,\n      stock_sync_opt_in\n    )\n    ${products\n      .map(product => {\n        return sql`\n          SELECT\n            ${product.productId} AS product_id,\n            ${clientSalesChannelId} AS client_sales_channel_id,\n            ${product.productRef} AS sales_channel_product_ref,\n            ${sqlValueOrNull(\n              product.clientSalesChannelListingId\n            )} AS client_sales_channel_listing_id,\n            clients.fulfilment_opt_in_default,\n            clients.stock_sync_opt_in_default\n          FROM\n            client_sales_channels\n          LEFT JOIN\n            client_integrations\n          ON\n            client_sales_channels.client_integration_id = client_integrations.client_integration_id\n          LEFT JOIN\n            clients\n          ON\n            clients.client_id = client_integrations.client_id\n          WHERE\n            client_sales_channel_id = ${clientSalesChannelId}\n        `;\n      })\n      .reduce(sqlReduceWithUnion)}\n    ON DUPLICATE KEY UPDATE\n      product_id = VALUES(product_id),\n      client_sales_channel_listing_id = VALUES(client_sales_channel_listing_id)\n  `;\n};\n\nmodule.exports = insertMatchedProducts;\n')),(0,a.kt)("h2",{id:"nest"},"nest"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"nest")," helper is used when you want to generate a nested query output from a resultset with multiple join statements. You can nest as many levels by providing multiple array items."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"mergeField")," attribute sets the column to be used for nesting.\n",(0,a.kt)("inlineCode",{parentName:"p"},"childrenLabel")," attribute sets the key for the nested objects.\n",(0,a.kt)("inlineCode",{parentName:"p"},"fieldsToKeep")," attribute determines the columns that will be kept under that nest branch."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, nest, camelKeys } = require("~root/lib/database");\n\nconst selectBlogsByTag = ({ userId }) => submitQuery`\n    SELECT     \n        blogs.blog_id,\n        blogs.user_id,\n        blogs.category_id,\n        blogs.description,\n        blogs.image,\n        blogs.slug,\n        blogs.title,\n        blogs.blog_content,\n        blogs.updated_at,\n        blogs.published_at,\n        tags.tag\n    FROM blogs\n    LEFT JOIN blog_tags ON blog_tags.blog_id = blogs.blog_id\n    LEFT JOIN tags ON tags.tag_id = blog_tags.tag_id\n    WHERE blogs.user_id = ${userId}\n`;\n\nmodule.exports = nest(camelKeys(selectBlogsByTag), [\n  {\n    mergeField: "blogId",\n    childrenLabel: "tags",\n    fieldsToKeep: [\n      "userId",\n      "blogContent",\n      "categoryId",\n      "description",\n      "image",\n      "publishedAt",\n      "slug",\n      "title",\n      "updatedAt"\n    ]\n  }\n]);\n')))}p.isMDXComponent=!0}}]);